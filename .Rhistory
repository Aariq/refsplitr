requireNamespace(package = "network", quietly = TRUE)
data <- data[!is.na(data$country), ]
data <- data[!is.na(data$lat), ]
data <- data[!is.na(data$lon), ]
## 	Link all authors at a particular point location:
data$latlon <- paste0(data$lat, ",", data$lon)
test <- data.frame(latlon = unique(data$latlon))
test$LAT <- as.numeric(lapply(strsplit(as.character(test$latlon), ","),
function(x) x[1]))
test$LON <- as.numeric(lapply(strsplit(as.character(test$latlon), ","),
function(x) x[2]))
test$latlonalpha <- paste0("a", seq_len(nrow(test)))
test1 <- merge(test, data[, c("latlon", "refID")], by = "latlon",
all.y = TRUE)
linkages <- Matrix::spMatrix(
nrow = length(unique(test1$latlonalpha)),
ncol = length(unique(test1$refID)),
i = as.numeric(factor(test1$latlonalpha)),
j = as.numeric(factor(test1$refID)),
x = rep(1, length(test1$latlonalpha))
)
links <- matrix(data = linkages,
nrow = length(unique(test1$latlonalpha)),
ncol = length(unique(test1$refID)))
rownames(links) <- levels(factor(test1$latlonalpha))
colnames(links) <- levels(factor(test1$refID))
## Convert to a one-mode representation of countries:
linkages_points <- links %*% t(links)
## 	Or we might be interested in using the network package instead of igraph:
## 	This loads our adjacency matrix into a network object, and we
## 		specify directed as FALSE, and because we use the ignore.eval=FALSE
## 		and names.eval="value" arguments it will load our edge counts in as
## 		an edge attribute named "value" which we can then use as a weighting
## 		or plotting attribute:
linkages_points_net <- network::network(as.matrix(linkages_points),
directed = FALSE,
loops = FALSE,
ignore.eval = FALSE,
names.eval = "value"
)
## 	Get the world map from rworldmap package:
world_map <- rworldmap::getMap()
edgeMaker <- function(whichRow, len = 100, curved = TRUE) {
adjacencyList$rowname <- as.character(adjacencyList$rowname)
adjacencyList$rownamesA <- as.character(adjacencyList$rownamesA)
fromC <- layoutCoordinates[layoutCoordinates$latlonalpha ==
adjacencyList[whichRow, 1], 2:3 ][1, ] # Origin
toC <- layoutCoordinates[layoutCoordinates$latlonalpha ==
adjacencyList[whichRow, 2], 2:3 ][1, ] # Terminus
# Add curve:
# graphCenter <- colMeans(layoutCoordinates[, 2:3]) #Center of overall graph
bezierMid <- as.numeric(c(fromC[1], toC[2])) # A midpoint, for bended edges
bezierMid <- (fromC + toC + bezierMid) / 3 # Moderate the Bezier midpoint
if (curved == FALSE) {
bezierMid <- (fromC + toC) / 2
} # Remove the curve
edge <- data.frame(Hmisc::bezier(
as.numeric(c(fromC[2], bezierMid[2], toC[2])), # Generate
as.numeric(c(fromC[1], bezierMid[1], toC[1])), # X & y
evaluation = len
)) # Bezier path coordinates
edge$Sequence <- 1:len # For size and colour weighting in plot
edge$Group <- paste(adjacencyList[whichRow, 1:2], collapse = ">")
return(edge)
}
adjacencyMatrix <- as.matrix(linkages_points)
layoutCoordinates <- test
adjacencydf <- data.frame(adjacencyMatrix)
adjacencydf <- data.frame(
rowname = rep(row.names(adjacencydf), times = nrow(adjacencydf)),
rownamesA = rep(row.names(adjacencydf), each = nrow(adjacencydf)),
value = c(as.matrix(adjacencydf)),
stringsAsFactors = FALSE)
adjacencyList <- adjacencydf[adjacencydf$value > 0, ]
# Generate a (curved) edge path for each pair of connected nodes
allEdges <- lapply(seq_len(nrow(adjacencyList)),
edgeMaker,
len = line_resolution,
curved = TRUE
)
allEdges <- do.call(rbind, allEdges) # a fine-grained path ^, with bend ^
empty_theme <- ggplot2::theme_bw() +
ggplot2::theme(
line = ggplot2::element_blank(),
#rect = ggplot2::element_blank(),
#axis.text = ggplot2::element_blank(),
#strip.text = ggplot2::element_blank(),
plot.title = ggplot2::element_blank(),
axis.title = ggplot2::element_blank(),
# plot.margin = structure(c(0, 0, -1, -1),
#                         unit = "lines",
#                         valid.unit = 3L,
#                         class = "unit"
# )
)
world_map_sub <- world_map
#world_map_sub <- ggplot2::fortify(world_map)
if (mapRegion != "world") {
world_map_sub <- world_map[which(world_map$continent == mapRegion &
world_map$TYPE != "Dependency"), ]
}
## 	Create the world outlines:
world_map@data$id <- rownames(world_map@data)
world_map.points <- ggplot2::fortify(world_map)
world_map.df <- merge(world_map.points,
world_map@data, by = "id", all = TRUE)
## calculate min and max for plot
latmin <- world_map_sub@bbox["y", "min"]
latmax <- world_map_sub@bbox["y", "max"]
longmin <- world_map_sub@bbox["x", "min"]
longmax <- world_map_sub@bbox["x", "max"]
if (mapRegion == "Australia"){
longmin <- 100
}
products <- list()
lat <- quo(lat)
long <- quo(long)
group <- quo(group)
x <- quo(x)
y <- quo(y)
Group <- quo(Group)
Sequence <- quo(Sequence)
LAT <- quo(LAT)
LON <- quo(LON)
lineAlpha <- enexpr(lineAlpha)
ggplot2::ggplot() +
ggplot2::geom_polygon(
data = world_map.df,
ggplot2::aes(!!long, !!lat, group = !!group),
fill = grDevices::gray(8 / 10)
) +
ggplot2::geom_path(
data = world_map.df,
ggplot2::aes(!!long, !!lat, group = !!group),
color = grDevices::gray(6 / 10)
) +
ggplot2::coord_equal(ylim = c(latmin, latmax),
xlim = c(longmin, longmax)) +
ggplot2::geom_path(
data = allEdges,
ggplot2::aes(
x = !!x, y = !!y,
group = !!Group, # Edges with gradient
colour = !!Sequence,
size = !!Sequence
),
alpha = lineAlpha
) +
ggplot2::geom_point(
data = data.frame(layoutCoordinates),
ggplot2::aes(x = !!LON, y = !!LAT),
size = 3 + 100 * sna::degree(linkages_points_net,
cmode = "outdegree", rescale = TRUE
),
pch = 21,
colour = grDevices::rgb(8 / 10, 2 / 10, 2 / 10, alpha = 5 / 10),
fill = grDevices::rgb(9 / 10, 6 / 10, 6 / 10, alpha = 5 / 10)
) +
ggplot2::scale_colour_gradient(
low = grDevices::rgb(8 / 10, 2 / 10, 2 / 10, alpha = 5 / 10),
high = grDevices::rgb(8 / 10, 2 / 10, 2 / 10, alpha = 5 / 10),
guide = "none"
)
ggplot2::ggplot() +
ggplot2::geom_polygon(
data = world_map.df,
ggplot2::aes(!!long, !!lat, group = !!group),
fill = grDevices::gray(8 / 10)
) +
ggplot2::geom_path(
data = world_map.df,
ggplot2::aes(!!long, !!lat, group = !!group),
color = grDevices::gray(6 / 10)
) +
ggplot2::coord_equal(ylim = c(latmin, latmax),
xlim = c(longmin, longmax)) +
ggplot2::geom_path(
data = allEdges,
ggplot2::aes(
x = !!x, y = !!y,
group = !!Group, # Edges with gradient
colour = !!Sequence,
size = !!Sequence
),
alpha = lineAlpha
)
ggplot2::ggplot() +
ggplot2::geom_polygon(
data = world_map.df,
ggplot2::aes(!!long, !!lat, group = !!group),
fill = grDevices::gray(8 / 10)
) +
ggplot2::geom_path(
data = world_map.df,
ggplot2::aes(!!long, !!lat, group = !!group),
color = grDevices::gray(6 / 10)
) +
ggplot2::coord_equal(ylim = c(latmin, latmax),
xlim = c(longmin, longmax))
ggplot2::ggplot() +
ggplot2::geom_polygon(
data = world_map.df,
ggplot2::aes(!!long, !!lat, group = !!group),
fill = grDevices::gray(8 / 10)
) +
ggplot2::geom_path(
data = world_map.df,
ggplot2::aes(!!long, !!lat, group = !!group),
color = grDevices::gray(6 / 10)
)
ggplot2::ggplot() +
ggplot2::geom_polygon(
data = world_map.df,
ggplot2::aes(!!long, !!lat, group = !!group),
fill = grDevices::gray(8 / 10)
)
ggplot2::ggplot() +
ggplot2::geom_polygon(
data = world_map.df,
ggplot2::aes(!!long, !!lat, group = !!group),
fill = grDevices::gray(8 / 10)
) +
ggplot2::geom_path(
data = world_map.df,
ggplot2::aes(!!long, !!lat, group = !!group),
color = grDevices::gray(6 / 10)
)
View(world_map.df)
world_map.df <- world_map.df[!is.na(world_map.df$lat), ]
## calculate min and max for plot
latmin <- world_map_sub@bbox["y", "min"]
latmax <- world_map_sub@bbox["y", "max"]
longmin <- world_map_sub@bbox["x", "min"]
longmax <- world_map_sub@bbox["x", "max"]
if (mapRegion == "Australia"){
longmin <- 100
}
products <- list()
lat <- quo(lat)
long <- quo(long)
group <- quo(group)
x <- quo(x)
y <- quo(y)
Group <- quo(Group)
Sequence <- quo(Sequence)
LAT <- quo(LAT)
LON <- quo(LON)
lineAlpha <- enexpr(lineAlpha)
products[["plot"]] <- ggplot2::ggplot() +
ggplot2::geom_polygon(
data = world_map.df,
ggplot2::aes(!!long, !!lat, group = !!group),
fill = grDevices::gray(8 / 10)
) +
ggplot2::geom_path(
data = world_map.df,
ggplot2::aes(!!long, !!lat, group = !!group),
color = grDevices::gray(6 / 10)
) +
ggplot2::coord_equal(ylim = c(latmin, latmax),
xlim = c(longmin, longmax)) +
ggplot2::geom_path(
data = allEdges,
ggplot2::aes(
x = !!x, y = !!y,
group = !!Group, # Edges with gradient
colour = !!Sequence,
size = !!Sequence
),
alpha = lineAlpha
) +
ggplot2::geom_point(
data = data.frame(layoutCoordinates),
ggplot2::aes(x = !!LON, y = !!LAT),
size = 3 + 100 * sna::degree(linkages_points_net,
cmode = "outdegree", rescale = TRUE
),
pch = 21,
colour = grDevices::rgb(8 / 10, 2 / 10, 2 / 10, alpha = 5 / 10),
fill = grDevices::rgb(9 / 10, 6 / 10, 6 / 10, alpha = 5 / 10)
) +
ggplot2::scale_colour_gradient(
low = grDevices::rgb(8 / 10, 2 / 10, 2 / 10, alpha = 5 / 10),
high = grDevices::rgb(8 / 10, 2 / 10, 2 / 10, alpha = 5 / 10),
guide = "none"
) +
ggplot2::scale_size(range = c(5 / 10, 5 / 10), guide = "none") +
empty_theme
products[["data_path"]] <- allEdges
products[["data_polygon"]] <- world_map.df
products[["data_points"]] <- data.frame(layoutCoordinates)
products
plot_net_country <- function(data,
lineResolution = 10,
mapRegion = "world",
lineAlpha = 0.5) {
data <- data[!is.na(data$country), ]
data$country[data$country %in% c('england', 'scotland')] <- 'united kingdom'
## 	Or, we could use a sparse matrix representation:
linkages <- Matrix::spMatrix(
nrow = length(unique(data$country)),
ncol = length(unique(data$UT)),
i = as.numeric(factor(data$country)),
j = as.numeric(factor(data$UT)),
x = rep(1, length(data$country))
)
links <- matrix(data = linkages,
nrow = length(unique(data$country)),
ncol = length(unique(data$UT)))
rownames(links) <- levels(factor(data$country))
colnames(links) <- levels(factor(data$UT))
## 	Convert to a one-mode representation of countries:
linkages_countries <- links %*% t(links)
## 	Convert to a one-mode representation of references:
## linkages_references <- t(links) %*% links
## 	This loads our adjacency matrix into a network object, and we
## 	specify directed as FALSE, and because we use the ignore.eval=FALSE
## 	and names.eval="value" arguments it will load our edge counts in as
##  an edge attribute named "value" which we can then use as a weighting
## 	or plotting attribute:
linkages_countries_net <- network::network(as.matrix(linkages_countries),
directed = FALSE,
loops = FALSE,
ignore.eval = FALSE,
names.eval = "value"
)
requireNamespace(package = "network", quietly = TRUE)
vertex_names <- (linkages_countries_net %v% "vertex.names")
vertex_names <- ifelse(vertex_names == "usa", "united states of america",
vertex_names)
## 	Get the world map from rworldmap package:
world_map <- rworldmap::getMap()
world_map$ADMIN.1 <- tolower(world_map$ADMIN.1)
vertexdf <- data.frame("ISO_A2" = vertex_names, stringsAsFactors = FALSE)
# coords_df <- suppressWarnings(dplyr::left_join(vertexdf,
#   world_map[c("ADMIN.1", "LON", "LAT")]@data,
#   by = c("ISO_A2" = "ADMIN.1")
# ))
coords_df <- suppressWarnings(merge(vertexdf,
world_map[c("ADMIN.1", "LON", "LAT")]@data,
by.x = "ISO_A2", by.y = "ADMIN.1", all.x = TRUE)
)
## 	It seems there are two "AU" codes, so we'll aggregate and mean them:
coords_df <- stats::aggregate(coords_df[c("LON", "LAT")],
by = list(factor(coords_df$ISO_A2)),
FUN = mean
)
names(coords_df) <- c("ISO_A2", "LON", "LAT")
## 	One could also use ggplot to plot out the network geographically:
maptools::gpclibPermit()
layoutCoordinates <- coords_df
# Function to generate paths between each connected node
edgeMaker <- function(whichRow, len = 100, curved = TRUE) {
adjacencyList$country <- as.character(adjacencyList$country)
adjacencyList$countryA <- as.character(adjacencyList$countryA)
layoutCoordinates$ISO_A2 <- as.character(layoutCoordinates$ISO_A2)
layoutCoordinates <- stats::na.omit(layoutCoordinates)
adjacencyList$country <- ifelse(adjacencyList$country == "usa",
"united states of america", adjacencyList$country)
adjacencyList$countryA <- ifelse(adjacencyList$countryA == "usa",
"united states of america", adjacencyList$countryA)
adjacencyList$country <- ifelse(adjacencyList$country == "V1",
NA, adjacencyList$country)
adjacencyList$countryA <- ifelse(adjacencyList$countryA == "V1",
NA, adjacencyList$countryA)
adjacencyList <- stats::na.omit(adjacencyList)
adjacencyList$country <- gsub(
pattern = "\\.", replacement = " ",
x = adjacencyList$country
)
adjacencyList$countryA <- gsub(
pattern = "\\.", replacement = " ",
x = adjacencyList$countryA
)
fromC <- layoutCoordinates[layoutCoordinates$ISO_A2 ==
adjacencyList[whichRow, 1], 2:3 ] # Origin
toC <- layoutCoordinates[layoutCoordinates$ISO_A2 ==
adjacencyList[whichRow, 2], 2:3 ] # Terminus
## Add curve:
# graphCenter <- colMeans(layoutCoordinates[, 2:3]) # Center of graph
bezierMid <- as.numeric(c(fromC[1], toC[2])) # A midpoint, for bended edges
bezierMid <- (fromC + toC + bezierMid) / 3 # Moderate the Bezier midpoint
if (curved == FALSE) {
bezierMid <- (fromC + toC) / 2
} # Remove the curve
edge <- data.frame(Hmisc::bezier(
as.numeric(c(fromC[1], bezierMid[1], toC[1])), # Generate
as.numeric(c(fromC[2], bezierMid[2], toC[2])), # X & y
evaluation = len
)) # Bezier path coordinates
edge$Sequence <- 1:len # For size and colour weighting in plot
edge$Group <- paste(adjacencyList[whichRow, 1:2], collapse = ">")
return(edge)
}
adjacencyMatrix <- as.matrix(linkages_countries)
rownames(adjacencyMatrix)[rownames(adjacencyMatrix) == "NA"] <- "NAstr"
colnames(adjacencyMatrix)[colnames(adjacencyMatrix) == "NA"] <- "NAstr"
adjacencyList <- data.frame(
country = rep(row.names(adjacencyMatrix), each = nrow(adjacencyMatrix)),
countryA = rep(colnames(adjacencyMatrix), times = nrow(adjacencyMatrix)),
value = c(adjacencyMatrix)
)
adjacencydf <- data.frame(adjacencyMatrix)
adjacencydf$country <- row.names(adjacencydf)
# adjacencyList <- tidyr::gather(data = adjacencydf, key = "countryA",
#   value = "value", -"country")
adjacencyList <- adjacencyList[adjacencyList$value > 0, ]
rownames(adjacencydf)[rownames(adjacencydf) == "NAstr"] <- "NA"
colnames(adjacencydf)[colnames(adjacencydf) == "NAstr"] <- "NA"
allEdges <- lapply(seq_len(nrow(adjacencyList)),
edgeMaker,
len = lineResolution,
curved = TRUE
)
allEdges <- do.call(rbind, allEdges)
requireNamespace(package = "ggplot2", quietly = TRUE)
empty_theme <- ggplot2::theme_bw() +
ggplot2::theme(
line = ggplot2::element_blank(),
#rect = ggplot2::element_blank(),
#axis.text = ggplot2::element_blank(),
#strip.text = ggplot2::element_blank(),
plot.title = ggplot2::element_blank(),
axis.title = ggplot2::element_blank(),
# plot.margin = structure(c(0, 0, -1, -1),
#                         unit = "lines",
#                         valid.unit = 3L,
#                         class = "unit"
# )
)
world_map_sub <- world_map
if (mapRegion != "world") {
world_map_sub <- world_map[which(world_map$continent == mapRegion &
world_map$TYPE != "Dependency"), ]
}
## 	Create the world outlines:
world_map@data$id <- rownames(world_map@data)
world_map.points <- ggplot2::fortify(world_map)
world_map.df <- merge(world_map.points,
world_map@data, by = "id", all = TRUE)
# world_map.df <- dplyr::full_join(world_map.points,
#   world_map@data, by = "id")
## calculate min and max for plot
latmin <- world_map_sub@bbox["y", "min"]
latmax <- world_map_sub@bbox["y", "max"]
longmin <- world_map_sub@bbox["x", "min"]
longmax <- world_map_sub@bbox["x", "max"]
if (mapRegion == "Australia"){
longmin <- 100
}
products <- list()
lat <- quo(lat)
long <- quo(long)
group <- quo(group)
x <- quo(x)
y <- quo(y)
Group <- quo(Group)
Sequence <- quo(Sequence)
LAT <- quo(LAT)
LON <- quo(LON)
ISO_A2 <- quo(ISO_A2)
lineAlpha <- enexpr(lineAlpha)
products[["plot"]] <- ggplot2::ggplot() +
ggplot2::geom_polygon(data = world_map.df, ggplot2::aes(!!long,
!!lat, group =!!group), fill = grDevices::gray(8 / 10)) +
ggplot2::geom_path(data = world_map.df, ggplot2::aes(!!long,
!!lat, group = !!group), color = grDevices::gray(6 / 10)) +
ggplot2::coord_equal(ylim = c(latmin, latmax),
xlim = c(longmin, longmax)) +
ggplot2::geom_path(
data = allEdges,
ggplot2::aes(x = !!x, y = !!y, group = !!Group,
colour = !!Sequence, size = !!Sequence), alpha = lineAlpha
) +
ggplot2::geom_point(
data = data.frame(layoutCoordinates), # Add nodes
ggplot2::aes(x = !!LON, y = !!LAT),
size = 5 + 100 * sna::degree(linkages_countries_net,
cmode = "outdegree", rescale = TRUE), pch = 21,
colour = grDevices::rgb(8 / 10, 2 / 10, 2 / 10, alpha = 5 / 10),
fill = grDevices::rgb(9 / 10, 6 / 10, 6 / 10, alpha = 5 / 10)
) +
ggplot2::scale_colour_gradient(low = grDevices::rgb(8 / 10, 2 / 10, 2 / 10,
alpha = 5 / 10), high = grDevices::rgb(8 / 10, 2 / 10, 2 / 10,
alpha = 5 / 10), guide = "none") +
ggplot2::scale_size(range = c(1, 1), guide = "none") +
ggplot2::geom_text(
data = coords_df,
ggplot2::aes(x = !!LON, y = !!LAT, label = !!ISO_A2), size = 2,
color = grDevices::gray(2 / 10)
) + empty_theme # Clean up plot
products[["data_path"]] <- allEdges
products[["data_polygon"]] <- world_map.df
products[["data_points"]] <- data.frame(layoutCoordinates)
return(products)
}
output <- plot_net_country(BITR_geocode)
library("network", lib.loc="~/R/x86_64-pc-linux-gnu-library/3.5")
output <- plot_net_country(BITR_geocode)
output$plot
plot_net_country(BITR_geocode, lineAlpha = 0.2)$plot
plot_net_country(BITR_geocode, lineAlpha = 0.8)$plot
source('~/r_programs/refsplitr/R/plot_net_country.R')
plot_net_country(BITR_geocode, lineAlpha = 0.8)$plot
plot_net_country(BITR_geocode, lineAlpha = 0.2)$plot
data(BITR)
setwd(..)
setwd('..)
setwd('..')
document()
devtools::document()
devtools::document()
